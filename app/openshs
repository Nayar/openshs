#!/bin/env python

import subprocess
import csv
from repeater import Repeater
from datetime import datetime, timedelta
import click
import os
import shutil
from collections import OrderedDict
import itertools

CONTEXTS = OrderedDict()
CONTEXTS['morning'] = {'exe': 'blender/morning.blend',
                         'start_dt': datetime.strptime("2016-02-01 08:00:00", "%Y-%m-%d %H:%M:%S")}
CONTEXTS['evening'] = {'exe': 'blender/evening.blend',
                         'start_dt': datetime.strptime("2016-02-01 18:00:00", "%Y-%m-%d %H:%M:%S")}

def validate_dt(value):
    try:
        dt = datetime.strptime(value, "%Y-%m-%d %H:%M:%S")
        return dt
    except ValueError:
        raise click.BadParameter("Please enter a valid datetime")

def get_file_names(path):
    files = os.listdir(path)
    return sorted([f.rstrip('.csv') for f in files], key=lambda x: datetime.strptime(x, "%Y-%m-%d %H:%M:%S"))

def parse_context_filenames(filenames):
    di = {}
    for f in filenames:
        x = f.split('_')
        di[x[0]] = x[1].rstrip('.csv')
    return di

def get_context_filenames(path):
    files = os.listdir(path)
    di = parse_context_filenames(files)
    return di

def get_contexts_dict():
    result = {}
    for context in CONTEXTS:
        di = get_context_filenames(CONTEXTS[context]['dataset_path'])
        for k in di:
            result[k] = {'repeat': int(di[k]), \
                         'filename': CONTEXTS[context]['dataset_path'] + k + '_' + str(di[k]) + '.csv'}

    return result

def sort_contexts_dict_by_day(scenarios_dict):
    sorted_dict = OrderedDict()
    sorted_keys = sorted(scenarios_dict, key=lambda x: datetime.strptime(x, "%Y-%m-%d %H:%M:%S"))
    for k in sorted_keys:
        sorted_dict[k] = scenarios_dict[k]
    return sorted_dict

@click.group()
def main():
    """OpenSHS: Open Smart Home Simulator"""
    pass

@main.command()
@click.option('--list-contexts', '-lc', default=False, is_flag=True, help='Lists the available contexts.')
@click.option('--recorded-contexts', '-rc', default=False, is_flag=True, help='Shows the status of the recorded contexts.')
def status(list_contexts, recorded_contexts):
    """Shows the current status of the experiment."""
    if list_contexts:
        click.echo(", ".join([x for x in CONTEXTS.keys()]))

    if recorded_contexts:
        for context in CONTEXTS:
            click.echo("For context " + click.style(context, bold=True) + ":")
            di = get_context_filenames(CONTEXTS[context]['dataset_path'])
            for k in sorted(di):
                click.echo("\t" + k + " repeated: " + di[k])

@main.command()
@click.option('--context', '-c', type=click.Choice(list(CONTEXTS.keys())), help='Which context to start.')
@click.option('--primusrun', '-p', default=False, is_flag=True, help='Start the context with primus support (Linux Only).')
def start(context, primusrun):
    """Start a context experiment."""
    click.echo('Starting the ' + click.style(context, bold=True) + ' context.')
    start_dt = click.prompt("What's the starting time?",
                            default=CONTEXTS[context]['start_dt'],
                            value_proc=validate_dt)
    CONTEXTS[context]['start_dt'] = start_dt
    if primusrun:
        subprocess.call(["primusrun", "blender", CONTEXTS[context]['exe']], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        subprocess.call(["blender", CONTEXTS[context]['exe']], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    weekday_p = click.prompt("Was that simulation for a weekday?", default=True, type=bool)

    os.rename('temp/output.csv', 'temp/' + ('weekday_' if weekday_p else 'weekend_') + context + '_' + datetime.strftime(start_dt, "%Y-%m-%d %H:%M:%S") + '.csv')

@main.command()
@click.option('--days', '-d', type=int, default=30, help='How many days to generate.', )
def aggregate(days):
    """Aggregate the datasets."""

    s_dict = get_contexts_dict()
    ss_dict = sort_contexts_dict_by_day(s_dict)

    aday = timedelta(days=1)

    # The header row
    first_el = list(ss_dict.items())[0][0]
    with open(ss_dict[first_el]['filename'], 'r') as headfile:
        csv_reader = csv.reader(headfile)
        header = next(csv_reader)
    header.append('timestamp')

    with open('datasets/dataset.csv', 'w') as outf:
        csv_writer = csv.writer(outf)
        csv_writer.writerow(header)

        d_rows = []
        for s_key in ss_dict:
            with open(ss_dict[s_key]['filename'], 'r') as inf:
                csv_reader = csv.reader(inf)
                next(csv_reader)
                rows = [x for x in csv_reader]
                start_dt = datetime.strptime(s_key, "%Y-%m-%d %H:%M:%S")
                for _ in range(ss_dict[s_key]['repeat']):
                    repeater = Repeater(rows, days, hasheader=False)
                    rep_rows = repeater.consData()
                    d_rows.append(add_timestamp_field(rep_rows, start_dt))
                    start_dt += aday

        flatten_rows = list(itertools.chain(*d_rows))
        sorted_rows = sorted(flatten_rows, key=lambda x: datetime.strptime(x[-1], "%Y-%m-%d %H:%M:%S"))
        csv_writer.writerows(sorted_rows)

def add_timestamp_field(reader, start_dt):
    if type(start_dt) is str:
        start_dt = datetime.strptime(start_dt, "%Y-%m-%d %H:%M:%S")
    ts = start_dt
    asec = timedelta(seconds=1)
    result = []

    for i in reader:
        row = i + [ts.strftime("%Y-%m-%d %H:%M:%S")]
        result.append(row)
        ts += asec
    return result


if __name__ == '__main__':
    main()
